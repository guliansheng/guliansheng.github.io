{"meta":{"title":"欢迎来到初学者博客!","subtitle":null,"description":null,"author":"guliansheng","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-09-10T10:11:08.000Z","updated":"2018-09-10T10:43:34.978Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"个人简介","date":"2018-09-10T14:56:59.000Z","updated":"2018-09-10T15:37:09.682Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-10T10:13:08.000Z","updated":"2018-09-10T10:44:00.428Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"面向对象4","slug":"面向对象4","date":"2018-09-11T02:54:50.000Z","updated":"2018-09-11T03:13:11.095Z","comments":true,"path":"2018/09/11/面向对象4/","link":"","permalink":"http://yoursite.com/2018/09/11/面向对象4/","excerpt":"本篇章讲述的是js中的面向对象编程，第四节主要介绍函数的几种形式和类数组的概念","text":"本篇章讲述的是js中的面向对象编程，第四节主要介绍函数的几种形式和类数组的概念 函数函数的属性1function Fn()&#123;&#125; length 形参的个数 name “Fn” 函数名 prototype 类的原型,在原型上定义的方法都是当前”Fn”这个类实例的公有方法 proto 把函数当做一个普通对象,指向Function这个类的原型 函数的三个角色 普通函数 : 它本身就是一个普通的函数，执行的时候形成私有的作用域（闭包），形参赋值，预解释，代码执行，执行完成后栈内存销毁/不销毁了 类 ：它有自己的实例，也有一个叫做prototype属性是自己的原型，它的实例都可以指向自己的原型 普通对象 ：和var obj=()中的obj一样，就是一个普通的对象，它作为对象可以有一些自己的私有的属性，也可以通过proto 找到Function.prototype 123456789101112function Fn()&#123; var num = 500; this.x = 100;&#125;Fn.prototype.getX = function()&#123; console.log(this.x);&#125;Fn.aaa = 1000;var f = new Fn;console.log(f.num);console.log(f.aaa);var res = Fn(); Function.prototype是函数类型的值,但是相关操作和之前一模一样,是一个密名函数 类数组类数组集合 arguments HTMLCollection NodeList 类数组转数组1var ary = Array.prototype.slice.call(obj) 元素集合(HTMLCollection)和节点集合(NodeList),在ie6~8中不支持借用数组方法 arguments没有兼容性问题,在ie6~8中可以借用数组方法 使用try-catch编写兼容代码12345678910111213var utils=&#123; listToArray:function(likeAry)&#123; var ary=[]; try&#123; ary=Array.prototype.slice.call(likeAry); &#125;catch(e)&#123; for(var i=0;i&lt;likeAry.length;i++)&#123; ary[ary.length]=likeAry[i]; &#125; &#125; return ary; &#125;&#125;","categories":[{"name":"js面向对象","slug":"js面向对象","permalink":"http://yoursite.com/categories/js面向对象/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"函数","slug":"函数","permalink":"http://yoursite.com/tags/函数/"},{"name":"类数组","slug":"类数组","permalink":"http://yoursite.com/tags/类数组/"}]},{"title":"面向对象3","slug":"面向对象3","date":"2018-09-11T02:51:04.000Z","updated":"2018-09-11T02:53:35.570Z","comments":true,"path":"2018/09/11/面向对象3/","link":"","permalink":"http://yoursite.com/2018/09/11/面向对象3/","excerpt":"本篇章讲述的是js中的面向对象编程，第三节主要介绍多种形式的继承","text":"本篇章讲述的是js中的面向对象编程，第三节主要介绍多种形式的继承 继承原型继承 “原型继承”是我们JS中最常用的一种继承方式 子类B想要继承父类A中的所有的属性和方法（私有+公有）,只需要让B.prototype=new A;即可 原型继承的特点:它是把父类中私有的 + 公有的都继承到了子类原型上(子类公有的),子类可以重写父类的属性和方法 核心：原型继承并不是把父类中的属性和方法克隆一份模一样的给B,而是让B和A之间增加了原型链的连接,以后B的实例b.想要用A中的getx方法,需要一级级的向上查找来使用 12345678910111213function A()&#123; this.name = 'this is A';&#125;A.prototype.getName = function()&#123; console.log(this.name)&#125;function B()&#123; this.name = 'this is B';&#125;B.prototype = new A;B.prototype.constructor = B;var b = new B;console.dir(b.getName()) call继承1234567891011function A()&#123; this.name = 'this is A';&#125;A.prototype.getName = function()&#123; console.log(this.name)&#125;function B()&#123; A.call(this);//将父类的私有属性和方法克隆一份,作为子类的私有属性和方法&#125;var b = new B;console.dir(b.getName()) 冒充对象继承 把父类私有的和公有的属性和方法克隆一份,作为子类的私有的属性和方法1234567891011121314function A()&#123; this.name = 'this is A';&#125;A.prototype.getName = function()&#123; console.log(this.name)&#125;function C()&#123; var temp = new A; for (var key in temp)&#123; this.[key] = temp[key]; &#125; temp = null;&#125;var c = new C; 混合模式继承 原型继承 + call继承 将父类私有的属性和方法克隆到子类的私有中,再将父类的私有和公有属性和方法添加到子类的公有中 12345678910111213function A()&#123; this.name = 'this is A';&#125;A.prototype.getName = function()&#123; console.log(this.name)&#125;function B()&#123; A.call(this);&#125;B.prototype = new A;B.prototype.constructor = B;var b = new B;console.dir(b.name) 寄生组合式继承 call继承 + Object.create() 父类私有的克隆到子类的私有中,父类的公有添加到子类的公有中 12345678910111213function A()&#123; this.name = 'this is A';&#125;A.prototype.getName = function()&#123; console.log(this.name)&#125;function B()&#123; A.call(this);//将父类的私有属性和方法克隆一份,作为子类的私有属性和方法&#125;B.prototype = Object.create(A.prototype);B.prototype.constructor = B;var b = new B;console.dir(b); 中间类继承法123456789function avgFn()&#123; console.log(arguments) arguments.__proto__ = Array.prototype; // arguments.sort(function (a,b)&#123;return a-b;&#125;); arguments.pop(); arguments.shift(); return eval(arguments.join(\"+\"))/arguments.length;&#125;console.log(avgFn(10,20,30,10,30,40,40))","categories":[{"name":"js面向对象","slug":"js面向对象","permalink":"http://yoursite.com/categories/js面向对象/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"继承","slug":"继承","permalink":"http://yoursite.com/tags/继承/"}]},{"title":"面向对象2","slug":"面向对象2","date":"2018-09-11T02:32:47.000Z","updated":"2018-09-11T03:23:24.390Z","comments":true,"path":"2018/09/11/面向对象2/","link":"","permalink":"http://yoursite.com/2018/09/11/面向对象2/","excerpt":"本篇章讲述的是js中的面向对象编程，第二节主要介绍原型链和原型链中的查找机制","text":"本篇章讲述的是js中的面向对象编程，第二节主要介绍原型链和原型链中的查找机制 原型链和原型链的查找机制函数和对象 【函数】 普通函数、类（所有的类：内置类(Array…)、自己创建的类） 【对象】 普通对象、数组、正则、Math、arguments… 实例是对象类型的（除了基本类到的字面量创建的值） prototype的值也是对象类型的 函数也是对象类型的 … 数据类型基本数据类型(值类型) number: 数字 除了常规的数字, 还有NaN NaN not a number: 不是一个数,但是属于number类型 NaN == NaN //=&gt;false , NaN和其他任何值都不相等 isNaN(): 检测值是否为有效数字, 如果不是返回true, 是有效数字返回false, 同时在检测时值如果不是number, 会将值转换为number类型再进行检测1console.log('12') //=&gt;false string: 字符串 boolean: 布尔 Boolean()方法, 只有0,NaN,空字符串, null, undefined这五个数据值转换为布尔类型的时候为false, 其余都是true; 可以直接用!!代替Boolean()来使用; null: 空对象指针 null用typeof返回的是Object undefined: 未定义 引用数据类型 object: 对象 {}: 普通对象 删除属性值12obj.xxx = null; //=&gt;假删除(让其属性值为null,,但是属性还在对象中)delete obj.xxx; //=&gt;真删除(把整个属性都在对象中暴力移除) []: 数组 /^$/: 正则 … function: 函数数据类型 普通函数 类(内置类, 自己创建的类) 数据类型检测 typeof: 检测数据类型的运算符 作用: 返回一个字符串, 内容证明值时属于什么类型的 局限: 无法将对象类型的中的数据类型进行细分 123456789typeof typeof [] //=&gt;\"string\"typeof function()&#123;&#125; //=&gt;\"function\"typeof 234 // =&gt; \"number\"typeof '基地搜' // =&gt; \"string\"typeof undefined //=&gt;\"undefined\"typeof &#123;&#125; // =&gt; \"object\"typeof [] // =&gt; \"object\"typeof /^$/ // =&gt; \"object\"typeof null // =&gt; \"object\" instanceof: 检测某个实例是否属于这个类 局限: 用字面量方式创建的基本数据类型用instanceof检测都为false, 只能用于new创建的基本数据类型检测 constructor: 获取当前实例的构造器 作用: 可以处理基本数据类型 局限: 我们可以把类的原型进行重写, 在重写的时候可能出现把之前的constructor给覆盖了, 这样检测出来的结构就是不正确的 Object.prototype.toString.call(): 获取当前实例的所属类信息 可以写成({}).toString.call() 最准确最常用的方式 作用 : 返回当前方法执行的主体(方法中this)所属类的详细信息,所有数据类型都可以检测,包括null和undefined toString():不仅仅是转换为字符串 1.Number类型的toString(2/10/8)方法,可以将数字转化成字符串,并且可以改变进制 2.Boolean类型转化为字符串就是将true/false转化为字符串 3.Array类型,RegExp类型,Data类型,Function类型可以直接转化为字符串 4.null和undefined没有toString方法 5.Math.toString() // =&gt; “[object Math]”,因为Math自身没有toString方法,这里是使用Object.prototype上的公有方法toString 6.对象数据类型 : ({}).toString() // =&gt; “[object Object]”,原理同上 原型属性:prototype 所有函数数据类型都有的自带属性 这个属性值是一个对象,浏览器会默认给他开辟一个堆内存 在浏览器给prototype开辟的堆内存中有一个天生自带的属性:constructor,这个属性存储的值是当前函数本身 每一个对象都有一个proto的属性,这个属性指向当前实例所属类的prototype(如果不能确定他是谁的实例,都是Object的实例) 每一个类都把供实例调取的公共属性方法，存储到自己的原型上（原型prototype的作用就是存储一些公共的属性和方法，供它的实例调取使用） 123456CreateUsPerson.prototype.writeJs=function()&#123; console.log(\"my name is\"+this.name+\"，i can write is 啦！！\");&#125;var p1=new CreateJsPerson(\"尹华芝\",18);var p2=new CreateUsPerson(\"王小波\",48);console.log(pl.writeJs === p2.writeJs);//-&gt;true,公有属性是相同的 原型链 它是一种基于proto(隐式原型)向上查找的机制。当我们操作实例的某个属性或者方法的时候,首先找自己空间中私有的属性或者方法 找到了，则结束查找，使用自己私有的即可 没有找到，则基于proto找所属类的prototype，如果找到就用这个公有的，如果没找到，基于原型上的proto继续向上查找，一直找到Object.prototype的原型为止，如果在没有，操作的属性或者方法不存在 批量设置公有属性 重构原型对象的方式 =&gt; 自己新开辟一个维内存，存储我们公有的属性和方法，把浏览器原来给Fn.prototype开辟的那个替换掉 只有浏览器天生给Fn.prototype开的堆内存里面才有constructor，而我们自己开辟的这个堆内存没有这个属性，这样constructor指向就不在是Fn而是Object了,我们需要手动添加该属性指向Fn 123456789101112function Fn()&#123; this.x=100;&#125;Fn.prototype=&#123; constructor:Fn,//手动添加一个constructor属性指向Fn; a:function()&#123; &#125;, b:function()&#123; &#125;&#125;;var f = new Fn;console.log(f.constructor);//没做任何处理,此时是Object 用这种方式给内置类增加公有的属性 我们这种方式会把之前已经存在于原型上的属性和方法给替换掉，所以我们中这种方式修改内置类的话，浏览器是给屏蔽掉的 但是我们可以一个个的修改内置的方法，当我们通过下述方式在数组的原型上增加方法，如果方法名和原来内置的重复了，会把人家内置的修改掉 =&gt; 我们以后在内置类的原型上增加方法，命名都需要加特殊的前缀 123Array.prototype.sort=function()&#123; console.log(\"ok\");// this-&gt;ary 我们当前要操作的这个数组&#125; for-in 循环遍历对象时需要添加一个判断 if(obj.hasOwnProperty(key)){},这样循环的就是私有属性 if(obj.propertyIsEnumerable(key)){},循环可枚举的,合上述相同","categories":[{"name":"js面向对象","slug":"js面向对象","permalink":"http://yoursite.com/categories/js面向对象/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"原型链","slug":"原型链","permalink":"http://yoursite.com/tags/原型链/"},{"name":"原型链的查找机制","slug":"原型链的查找机制","permalink":"http://yoursite.com/tags/原型链的查找机制/"}]},{"title":"面向对象1","slug":"面向对象1","date":"2018-09-11T01:58:47.000Z","updated":"2018-09-11T02:37:56.330Z","comments":true,"path":"2018/09/11/面向对象1/","link":"","permalink":"http://yoursite.com/2018/09/11/面向对象1/","excerpt":"本篇章讲述的是js中的面向对象编程，其中包含面向对象的概念，原型链机制，函数的继承等，第一节主要介绍概念相关知识","text":"本篇章讲述的是js中的面向对象编程，其中包含面向对象的概念，原型链机制，函数的继承等，第一节主要介绍概念相关知识 概念对象 万物皆对象 类 对象的具体细分 按照功能特点进行分类：大类，小类 类都是函数数据类型的 实例 类中具体的一个事物 拿出类别中的具体一个实例进行研究，那么当前类别下的其他实例也具备这特点和特征 实例都是对象数据类型的 构造函数执行机制像普通函数执行一样，形成一个私有的作用域(栈内存) 形参赋值 变量提升 都是私有变量 创建堆内存 在JS代码自上而下执行之前，首先在当前形成的私有栈中创建一个对象（创建一个堆内存：暂时不存储任何的东西），并且让函数中的执行主体（THIS）指向这个新的堆内存（THIS===创建的对象），堆内存的地址赋值给了THIS 代码自上而下执行 也就是开始创建的对象其实就是当前Fn这个类的一个实例，我们让this指向这个实例，代码执行中的this.xxx=xxx都是给实例设置“私有属性”最后浏览器会把默认创建的实例返回，供外面接收。 代码执行完成 把之前创建的堆内存地址返回(浏览器默认返回，不需要return操作) 多次执行new操作 就是把上面的操作克隆一份，会形成新的实例(新的内存空间)，所以说实例是独立分开的","categories":[{"name":"js面向对象","slug":"js面向对象","permalink":"http://yoursite.com/categories/js面向对象/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"},{"name":"面向对象概念","slug":"面向对象概念","permalink":"http://yoursite.com/tags/面向对象概念/"},{"name":"函数执行","slug":"函数执行","permalink":"http://yoursite.com/tags/函数执行/"}]},{"title":"javaScript基础4","slug":"javaScript基础4","date":"2018-09-10T13:24:34.000Z","updated":"2018-09-11T03:23:11.191Z","comments":true,"path":"2018/09/10/javaScript基础4/","link":"","permalink":"http://yoursite.com/2018/09/10/javaScript基础4/","excerpt":"本篇是JavaScript基础第四节，这是js基础的最后一个篇章，主要讲述事件的基础以及事件的传播机制，DOM二级事件绑定 文中出现的html代码样式请自行设置","text":"本篇是JavaScript基础第四节，这是js基础的最后一个篇章，主要讲述事件的基础以及事件的传播机制，DOM二级事件绑定 文中出现的html代码样式请自行设置 事件非常用事件 onmousewheel (鼠标滚轮滚动行为) onresize (window.onresize浏览器窗口大小改变事件) onunload (浏览器关闭事件) 鼠标事件 原型链: MouseEvent –&gt; UIEevent –&gt; Event –&gt; Object MouseEvent 记录的是页面中唯一一个鼠标每一次触发时候的相关信息,和到底在哪个元素上触发的没有关系 pageX | Y兼容处理 : event.pageX | Y = event.pageX | Y || (e.clientX + (document.documentElement.scrollLeft | Top || document.body.scrollLeft | Top)); 事件传播机制 先进行捕获阶段,再到目标阶段(可以不加),最后是冒泡阶段 使用DOM零级事件给元素的某一个行为绑定的方法,都是在行为触发后的冒泡阶段把方法执行的 无论元素是否绑定行为方法,都会触发相关事件,并进行事件传播,只是不绑定方法的不会有方法被执行 事件监听12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;body&gt; &lt;div class=\"box1\"&gt; &lt;div class=\"box2\"&gt; &lt;div class=\"box3\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let box1=document.querySelector('.box1'); let box2=document.querySelector('.box2'); let box3=document.querySelector('.box3'); var Event = &#123; addEvent: function(element,type,callback)&#123; if(element.addEventListener)&#123; element.addEventListener(type,callback,false); &#125;else if(element.attachEvent)&#123; element.attachEvent('on' + type,callback);//只在冒泡阶段发生,ie6~8兼容,也可以在ie9+使用 &#125; &#125;, removeEvent: function(element,type,callback)&#123; if(element.removeEventListener)&#123; element.removeEventListener(type,callback,false); &#125;else&#123; element.detachEvent('on' + type, callback); &#125; &#125;, getEvent: function(event)&#123; event = event || window.event; return event; &#125;, getTarget: function(event)&#123; if(window.event)&#123;event=window.event&#125; return event.target || event.srcElement; &#125;, stopPropagation: function(event)&#123; if(window.event)&#123;event=window.event&#125; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble = true; &#125; &#125;, preventDefault: function(event)&#123; if(window.event)&#123;event=window.event&#125;//兼容ie获取事件对象； if(event.prevenDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125; &#125; &#125; Event.addEvent(box3,'click',function click(event)&#123; alert(box3.className); console.log(Event.getEvent(event.target)); //参数:元素对象 , 移除的行为 , 移除的绑定方法名 Event.removeEvent(box3,'click',click); &#125;); Event.addEvent(box2,'click',function click(event)&#123; alert(box2.className); console.log(event); console.log(Event.getEvent(event.type)); Event.removeEvent(box2,'click',click); &#125;); Event.addEvent(box1,'click',function click(event)&#123; alert(box1.className); console.log(Event.getEvent(event.target)); Event.removeEvent(box3,'click',click); &#125;);&lt;/script&gt; 事件委托123456789101112131415161718192021&lt;body&gt; &lt;ul id=\"list\"&gt; &lt;li id=\"item1\" &gt;item1&lt;/li&gt; &lt;li id=\"item2\" &gt;item2&lt;/li&gt; &lt;li id=\"item3\" &gt;item3&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;&lt;script&gt; //利用事件的冒泡机制(触发当前元素的某个行为,他父级所有元素的相关行为都会触发),如果一个容器中有很多元素都绑定点击事件,我们没必要一个个的绑定了,只需要给最外层容器绑定一个点击事件即可,在这个方法执行的时候,通过事件源的区分来进行不同的操作; var list = document.getElementById(\"list\"); document.addEventListener(\"click\",function(event)&#123; var target = event.target;//event.target返回触发该事件的元素； if(target.tagName == \"LI\")&#123;//当元素为li标签时（tagName和nodeName都可以） //TODO alert(target.innerHTML); &#125; &#125;) var node=document.createElement(\"li\"); node.innerHTML='这还少'; list.appendChild(node);&lt;/script&gt; DOM二级事件绑定原理 是让元素对象通过原型链一直找到EventTarget这个内置类原型上的addEventListener方法实现的 二级事件绑定和零级事件绑定的区别 DOM零级事件绑定 : 只能给一个元素的某个行为绑定一次方法, 第二次绑定会把之前的覆盖掉 DOM二级事件绑定 : 可以给某个元素同一个行为绑定多个 “不同” 的方法 , 如果方法相同只能留一个 , 但是在捕获和冒泡阶段可以为同一个行为绑定同一个方法,因为是在不同阶段执行的 DOM零中的事件类型都可以绑定 , 并且DOM二级中提供了一些DOM零级没有的行为类型 (DOMContentLoaded : 当页面中的DOM结构[html结构]加载完成时触发的行为) window.onload = function(){} -&gt; 当页面中的所有资源加载完成(图片 , HTML结构 , 音视频 …)才会执行后面的函数;并且同一个页面中只能用一次 , 后面再写会把前面的覆盖掉; =&gt; 因为他是采用DOM零级事件绑定的 jQuery: \\$(document).ready(function(){}) -&gt; $(function(){}) 只要当前页面中的HTML结构加载完成就会执行对应的函数;并且同一个页面中可以出现多次;这是因为他采用DOM二级事件绑定 , 并且绑定的行为是DOM二级中新增的DOMContentLoaded 绑定和移除 绑定: el.addEventListener(‘行为’ , 方法名 , 传播方式); 移除: el.removeEventListener(‘行为’ , 方法名 , 传播方式); 执行过程 可以给某个元素同一个行为绑定多个 “不同” 的方法 , 如果方法相同只能留一个 , 但是在捕获和冒泡阶段可以为同一个行为绑定同一个方法,因为是在不同阶段执行的 当行为触发 , 会按照绑定的先后顺序依次把绑定的方法执行 执行的方法中的this就是当前被绑定事件的元素本身 ie6~8兼容问题 顺序问题：执行的时候顺序是混乱的，标淮浏览器是按照绑定顺序依次执行的 重复问题：IE6～8可以给同一个元素的同一个行为绑定多个相同的方法 this问题：IE6～8中当方法执行的时候，方法中的this不是当前绑定的元素而是window","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"},{"name":"事件基础","slug":"事件基础","permalink":"http://yoursite.com/tags/事件基础/"},{"name":"二级事件绑定","slug":"二级事件绑定","permalink":"http://yoursite.com/tags/二级事件绑定/"}]},{"title":"javaScript基础3","slug":"javaScript基础3","date":"2018-09-10T13:07:06.000Z","updated":"2018-09-11T02:38:29.082Z","comments":true,"path":"2018/09/10/javaScript基础3/","link":"","permalink":"http://yoursite.com/2018/09/10/javaScript基础3/","excerpt":"本篇是JavaScript基础第三节，本章介绍正则的相关知识，详细介绍了正则的特性和应用","text":"本篇是JavaScript基础第三节，本章介绍正则的相关知识，详细介绍了正则的特性和应用 正则表达式正则含义 他就是一个规则,用来处理字符串的一个规则(正则就是用来处理字符串) 创建正则 字面量方式: var reg = /\\d/; 实例创建方式: var reg = new RegExp(“”); 正则两种创建方式是有区别的 在字面量方式中 , ‘//’之间包起来的所有 内容都是元字符,有的具有特殊的意义,大部分都是代表本身含义的普通元字符 12345678910var name = 'gu'var reg = /^\\d+\"+name+\"\\d+$/;//并不是字符串拼接console.log(reg.test('200gu222')) //-&gt;flaseconsole.log(reg.test('200'''guuu'222)) //-&gt;true//所以这种需求只能用实例方式创建var name = 'gu';reg = new RegExp(\"^\\\\d+\"+name+\"\\\\d+$\",\"g\");//这种方式创建时要注意转义字符console.log(reg.test('200gu222')) //-&gt;true; 字面量中直接写\\d就可以了,实例方式中需要转义 \\\\d 处理字符串 匹配 : 使用reg.test(str)判断一个字符串是否符合我们制定的规则 1234var reg = /\\d/;console.log(reg.test('zhu')); //-&gt;falseconsole.log(reg.test('1')); //-&gt;trueconsole.log(reg.test('zhufeng01')); //-&gt;true 捕获 : 使用reg.exec(str)把字符串中符合我们正则规则的内容捕获到 123var reg = /\\d/;console.log(reg.exec('zhu')); //-&gt;nullconsole.log(reg.exec('1')); //-&gt; 1 exec和match的区别 123456var str2 = 'gu123gu234gu4560';var reg2 = /gu(\\d+)/g;console.log(reg2.exec(str2)) //=&gt;[\"gu123\",\"123\"...]console.log(reg2.exec(str2)) //=&gt;[\"gu234\",\"234\"...]console.log(reg2.exec(str2)) //=&gt;[\"gu345\",\"345\"...]console.log(str2.match(reg2)) //=&gt;[\"gu123\",\"gu234\",\"gu345\"] 正则捕获 每一次捕获的时候都是先进行默认匹配,如果没有匹配成功的,捕获的结果是null;只有有匹配的内容我们才能捕获到 捕获的内容: 捕获到的内容是一个数组 数组中的第一项是当前正则捕获的内容 index : 捕获内容在字符串中开始的索引位置 input : 捕获的原始字符串 正则捕获特点: 懒惰性 : 每一次执行exec只捕获第一匹配内容,在不进行任何处理的情况下,再次执行多次捕获,捕获内容还是第一匹配的内容 lastIndex : 是正则每一次捕获在字符串中开始查找的位置, 默认值是0, 如果不做任何处理, 每一次值都是0, 可以加全局修饰符 g 改变该值; 贪婪性 : 正则每一次捕获都是按照匹配最长的结果捕获的, 符合正则条件时, 会完全捕获到 解决贪婪性, 在量词元字符后面加上?元字符 1234var reg = /\\d+?/g;var str = \"29839jlsafi78789\";//不加?结果:[\"29839\"...]console.log(reg.exec(str));//=&gt;[\"2\"...] 字符串方法match()可以直接获取到所有符合正则的内容, 不需要循环执行exec方法,但是match只能捕获大正则匹配的内容, 而对小正则捕获的内容是无法获取的(不能获取到分组的正则匹配) 正则分组 分组引用 1234// \\1代表和第一个分组一模一样的内容, \\2代表和第二个分组一模一样的内容, 和对应的分组中的内容的值都要一样var reg = /^(\\w)\\1(\\w)\\2$/;console.log(reg.test(\"ffzz\"));//trueconsole.log(reg.test(\"fzz_\"));//false 分组捕获 : 正则捕获的时候, 不仅仅把大正则匹配的内容捕获到, 而且还可以把小分组匹配的内容捕获到 123456789101112// 在分组中使用 ?: 是只匹配不捕获var str = '342622199501013638';var reg=/^(\\d&#123;2&#125;)(\\d&#123;4&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d)(?:\\d|X)$/;console.log(reg.exec(str));// =&gt; [\"342622199501013638\", \"34\", \"2622\", \"1995\", \"01\", \"01\", \"36\", \"3\", index: 0, input: \"342622199501013638\"]console.log(str.match(reg))//和上面效果相同var str2 = 'gu123gu234gu4560';var reg2 = /gu(\\d+)/g;console.log(reg2.exec(str2)) //=&gt;[\"gu123\",\"123\"...] console.log(reg2.exec(str2)) //=&gt;[\"gu234\",\"234\"...]console.log(reg2.exec(str2)) //=&gt;[\"gu345\",\"345\"...]console.log(str2.match(reg2)) //=&gt;[\"gu123\",\"gu234\",\"gu345\"] replace执行机制 1234567//和exec的机制相似var str = 'gu2893gu898gu674';var reg = /gu(\\d+)/g;str.replace(reg,function()&#123; //捕获几次, 执行几次密名函数 console.log(arguments) //arguments就是捕获到的值组成的类数组, 同样可以捕获到分组的内容 return 'gu捕获到了' //return的值就是要替换的值&#125;) 常用正则123456789101112131415161718192021222324252627282930313233343536//1.有效数字正则：正数,负数,0,小数//-&gt; \".\"可能出现, 可能不出现,出现后面必须跟一位或多位数字//-&gt; 最开始可以有+/-也可以没有//-&gt; 整数部分, 一位数也可以是0~9之间的一个, 多位数不能以0开头////注意：//-&gt; []中出现的所有字符只是自身字符的含义, 没有特殊含义var reg = /^[+-]?(\\d|[1-9]\\d+)(\\.\\d+)?$///2.年龄在18~65//-&gt; 18-19阶段//-&gt; 20-59阶段//-&gt; 60-65阶段////注意：//-&gt; []中不识别两位数//-&gt; [12] 1或者2//-&gt; [12-67] 1 , 2-6 , 7中的一个var reg = /^(1[8-9]|[2-5]\\d|6[0-5])$///3、验证邮箱的正则(简版)//左边：数字、字母、下环线、.、var reg=/^[\\w.-]+@[0-9a-zA-Z]+(\\.[a-zA-Z]&#123;2,4&#125;)&#123;1,2&#125;$/;console.log(reg.test('1229303942@qq.com'))//4、中国标准真实姓名2-4位汉字var reg = /^[\\u4e00-\\u9fa5]&#123;2,4&#125;$/;console.log(reg.test('顾连生'))//5、身份证号码//var reg=/^\\d&#123;17&#125;(\\d|X)$/;//13 0828 1990 12 04 06 1 7var str = '342622194502047680';var reg=/^(\\d&#123;2&#125;)(\\d&#123;4&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d)(\\d|X)$/;console.log(reg.exec(str));console.log(str.match(reg));","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"javaScript基础2","slug":"javaScript基础2","date":"2018-09-10T13:04:21.000Z","updated":"2018-09-11T02:38:20.457Z","comments":true,"path":"2018/09/10/javaScript基础2/","link":"","permalink":"http://yoursite.com/2018/09/10/javaScript基础2/","excerpt":"本篇是JavaScript基础第二节，主要介绍DOM的相关操作和元素属性值设置 注：文中的[context]表示元素对象","text":"本篇是JavaScript基础第二节，主要介绍DOM的相关操作和元素属性值设置 注：文中的[context]表示元素对象 DOM元素获取方法 document.getElementById (一个元素对象) [context].getElementsByTagName (元素集合) [context].getElementsByClassName (元素集合) document.getElementsByName (节点集合[NodeList]) document.documentElement (获取整个HTML对象) document.body (获取整个BODY对象) document.head (获取整个HEAD对象) [context].querySelector (一个元素对象) [context].querySelectorAll (获取元素集合) 元素节点 元素节点 nodeType：1 nodeName：大写标签名（在部分浏览器的怪异模式下，我们写的标签名是小写，它获取的就是小写.…） nodeValue：null [curEle].tagName：获取当前元素的标签名（获取的标签名一般都是大写） 文本节点 nodeType：3 nodeName：#text nodeValue：文本内容 注释节点 nodeType：8 nodeName：#comment nodeValue：注释内容 文档节点 nodeType：9 nodeName：#document nodeValue：null 节点关系 previousSibling：获取当前节点的上一个哥哥节点（不一定是元素节点也可能是文本或者注释） nextSibling：获取当前节点的下一个弟弟节点 firstChild：当前元素所有子节点中的第一个（也不一定是元素节点，可能是文本和注释） lastChild：当前元素所有子节点中的最后一个 previousElementSibling：获取当前节点的上一个哥哥元素节点 nextElementSibling：获取当前节点的下一个弟弟元素节点 firstElementChild 第一个子元素节点 lastElementChild 最后一个子元素节点 获取[元素节点] (不是节点) 的方法都不兼容IE6~8; DOM渲染 回流(重排 reflow) ： 当页面中的HTML结构发生变化(增加，删除元素，位置发生变化…)，浏览器都需要重新计算一遍最新的DOM结构，重新对当前页面进行渲染 js中要尽量减少回流 重绘 ： 某一个元素的部分样式发生改变，浏览器只需要重新渲染当前元素即可 DOM映射机制 页面中的标签和js中获取到的元素对象(元素集合)是紧紧的绑定在一起的，页面中的HTML结构发生改变了，js中不需要重新获取，集合里面的内容也会跟着自动改变123456var oUl=document.getElementById(\"ul\");var oLis=oUl.getElementsByTagName(\"li\");console.log(oLis.length);//-&gt;6var oLi=document.createElement(\"li\");oUl.appendChild(oLi);console.log(oLis.length);//-&gt;7 没有重新的获取，但是oLis这个集合中的长度和内容会自动跟着发生改变 属性设置设置自定义属性方法的区别 xxx.index：是把当前操作的元素当做一个普通对象，为其设置一个属性名，和页面中的HTML标签没关系，不会在dom元素身上显示，但是可以在对象身上添加相应属性值 xxx.setAttribute：把元素当做特殊的元素对象来处理，设置的自定义属性是和页面结构中的DOM元素映射在一起的，可以在HTML结构中看到设置的属性，但是没有在对象身上添加相应属性 自定属性和元素自带属性 与页面HTML结构无关的普通对象 与页面HTML结构存在映射关系的元素对象 元素对象中的内置属性，大部分都和页面的标签存在映射关系 xxx.style.backgroundColor=’xxx’此时不仅把JS中对象对应的属性值改变了，而且也会映射到页面的HTML标签上（标签中有一个style行内样式、元素的样式改变了） xxx.className=’xxx’此时不仅是把S对象中的属性值改了，而且页面中的标签增加了class样式类（可以看见的）","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"},{"name":"DOM基础","slug":"DOM基础","permalink":"http://yoursite.com/tags/DOM基础/"},{"name":"元素属性设置","slug":"元素属性设置","permalink":"http://yoursite.com/tags/元素属性设置/"}]},{"title":"javaScript基础1","slug":"javaScript基础1","date":"2018-09-10T12:24:00.000Z","updated":"2018-09-11T02:38:10.961Z","comments":true,"path":"2018/09/10/javaScript基础1/","link":"","permalink":"http://yoursite.com/2018/09/10/javaScript基础1/","excerpt":"本篇是JavaScript基础第一节，主要是查漏一些基础内容和平时可能不注意的地方, 有问题可在下方留言","text":"本篇是JavaScript基础第一节，主要是查漏一些基础内容和平时可能不注意的地方, 有问题可在下方留言 基础弹出框 弹出框的内容最后都会被转换为字符串输出(调用toString这个方法)1alert(1 + 1);//=&gt;\"2\"; 控制台 console.dir()：比console.log()更加详细 console.table()：将json以表格形式展现出来 命名规范 常用简写 info：information 信息 init：initialization 初始化 add / insert / create：增加/创建/插入 remove / rm / clear / del / delete：删除 get / query / select：查询/获取 常规规范 var _XXX：一般以下划线开头的代表变量是一个全局或者公用的变量 JS中很多的词都是有特殊含义的，我们这些词叫做关键字；现在没有特殊含义，以后可能会作为关键词的，我们叫做保留字；而关键字和保留字都不可以随便用来命名 数据类型转换 ‘==’ 两边 两个等于号比较，左右两边数据值的类型不一样，浏览器会把两边的类型使用Number()方法都转换为数字然后再比较，但是null和undefined除外 123null == undefined //=&gt; truenull === undefined //=&gt; false null == 0 //=&gt;false null和undefined和其他任何值都不相等 等号两边类型相同,进行 ‘===’ 比较 Math random 获取[n,m]之间的随机整数 1Math.round(Math.random()*(m-n)+n) 括号表达式12345678910function fn1() &#123; console.log(this);&#125;function fn2() &#123; console.log(this);&#125;var json = &#123;name:'gu',fn:fn2&#125;;;(fn1,fn2)() //括号表达式中每一项用\",\"隔开，最后只能获取到最后一项;(fn1,json.fn)() //这里只是将json.fn指向的fn2函数直接拿过来使用，所以this还是指向window;(json.fn)() //只有一项时，this还是指向json","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"},{"name":"控制台","slug":"控制台","permalink":"http://yoursite.com/tags/控制台/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-09-09T05:49:54.022Z","updated":"2018-09-10T09:14:54.848Z","comments":true,"path":"2018/09/09/hello-world/","link":"","permalink":"http://yoursite.com/2018/09/09/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"text","slug":"text","permalink":"http://yoursite.com/categories/text/"}],"tags":[{"name":"初始化文章","slug":"初始化文章","permalink":"http://yoursite.com/tags/初始化文章/"},{"name":"hello world","slug":"hello-world","permalink":"http://yoursite.com/tags/hello-world/"}]}]}